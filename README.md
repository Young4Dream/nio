##缓冲区
缓冲区是特定基本类型元素的线性有限序列。除内容外，缓冲区的基本属性还包括容量、限制和位置：

- 缓冲区的容量 
是它所包含的元素的数量。缓冲区的容量不能为负并且不能更改。

- 缓冲区的限制 
是第一个不应该读取或写入的元素的索引。缓冲区的限制不能为负，并且不能大于其容量。

- 缓冲区的位置 
是下一个要读取或写入的元素的索引。缓冲区的位置不能为负，并且不能大于其限制。

对于每个非 boolean 基本类型，此类都有一个子类与之对应。
##不变式
标记、位置、限制和容量值遵守以下不变式：

> 0 <= 标记 <= 位置 <= 限制 <= 容量

新创建的缓冲区总有一个位置和一个未定义的标记。初始限制可以为 0，也可以为其他值，这取决于缓冲区类型及其构建方式。一般情况下，缓冲区的初始内容是未定义的。

##清除、反转和重绕
除了访问位置、限制、容量值的方法以及做标记和重置的方法外，此类还定义了以下可对缓冲区进行的操作：

- clear() 使缓冲区为一系列新的通道读取或相对放置 操作做好准备：它将限制设置为容量大小，将位置设置为 0。
- flip() 使缓冲区为一系列新的通道写入或相对获取 操作做好准备：它将限制设置为当前位置，然后将位置设置为 0。
- rewind() 使缓冲区为重新读取已包含的数据做好准备：它使限制保持不变，将位置设置为 0。

##直接与非直接缓冲区
- 字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则Java虚拟机会尽最大努力直接在此缓冲区上执行本机I/O操作。
    也就是说，在每次调用基础操作系统的一个本机I/O操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从
    中间缓冲区中复制内容）。
- 直接字节缓冲区可以通过调用此类的`allocateDirect()`方法来创建。此方法返回缓冲区
    进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以主流在常规的垃圾回收堆之外。
    因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机I/O操作影响的
    大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。
- 直接字节缓冲区还可通过FileChannel的map()方法将文件区域直接映射到内存中来创建。该方法反悔MappedByteBuffe。Java平台
    的实现有助于通过JNI从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域
    不会更改该缓存区的内容，并且将会在访问期间活稍后的某个时间导致跑出不确定的异常。
- 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其isDirect()方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓存区管理。
